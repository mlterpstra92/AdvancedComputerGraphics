void main(
  float4 color : TEXCOORD0,
  float3 pCrossMinV   : TEXCOORD1,
  float3 minUCrossP   : TEXCOORD2,
  float3 uCrossV   : TEXCOORD3,
  float depthin : TEXCOORD4,
  float2 pscreen : TEXCOORD5,
  float2 wpos : WPOS,
  
  uniform float near,
  uniform float2 unproj_scale,
  uniform float2 unproj_offset,
  uniform float screenSpaceRadius,
  
  uniform float zb_scale,
  uniform float zb_offset,
  
  uniform float epsilon,
  
  out float depthout : DEPTH,
  out float4 colorout : COLOR0,
  out float4 normalsout : COLOR1)
{
  //unproj_scale = float2(0.000105, 0.000105);
  //unproj_offset = float2(0.026795, 0.026795);
  
  float3 qn = float3(wpos*unproj_scale - unproj_offset, -near);
  float dn = dot(qn, uCrossV);
  float u = dot(qn, pCrossMinV)/dn;
  float v = dot(qn, minUCrossP)/dn;
  
  float dist_sq = u * u + v * v;
  // Normalized squared distance between vertex point in screen space and fragment position
  float dist_screen = ((pscreen.x - wpos.x) * (pscreen.x - wpos.x) + (pscreen.y - wpos.y) * (pscreen.y - wpos.y)) / (screenSpaceRadius * screenSpaceRadius);
  
  if(dist_sq > 1.0 && dist_screen > 1.0)
  {
    discard;
  }
  // First do min, then square root to save computational time
  float dist = sqrt(min(dist_sq, dist_screen));
  float alpha = smoothstep(1.0, 0.0, dist);
  
  float lambda = depthin/dn;
  
  float qz = qn.z * lambda + epsilon;
  depthout = zb_scale/qz + zb_offset;
  
  // We're turned of blending, so we manually multiply the color by the alpha.
  colorout.rgb = color.rgb * alpha;  
  colorout.a = alpha;
  
  // Write out the normals and lambda (for reconstructing surface
  // position), and again blend them by multiplying by the alpha.
  normalsout = float4(uCrossV * alpha, lambda * alpha);
}
