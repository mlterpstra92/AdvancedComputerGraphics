float3 calc_normal(float2 wpos, float depth, uniform sampler2D depth_values, uniform float2 C, uniform float2 wsize, uniform float4x4 proj_matrix) {
    // https://github.com/halcy/simpleflow/blob/master/WaterSim2/curvatureflow.frag

    float depth_dxp = tex2Dfetch(depth_values, int4(wpos.x + 1, wpos.y, 0, 0)).x;
    float depth_dxn = tex2Dfetch(depth_values, int4(wpos.x - 1, wpos.y, 0, 0)).x;
    float depth_dx = 0;
    float depth_dy = 0;
    if (depth_dxp == 0.0)
    {
        if (depth_dxn == 0.0f)
        {
            depth_dx = 0.0;
        } else {
            depth_dx = depth - depth_dxn;
        }
    }
    else
    {
        depth_dx = depth_dxp - depth;
    }

    float depth_dyp = tex2Dfetch(depth_values, int4(wpos.x, wpos.y + 1, 0, 0)).x;
    float depth_dyn = tex2Dfetch(depth_values, int4(wpos.x, wpos.y - 1, 0, 0)).x;
    if (depth_dyp == 0.0)
    {
        if (depth_dyn == 0.0f)
        {
            depth_dy = 0.0;
        } else {
            depth_dy = depth - depth_dyn;
        }
    }
    else
    {
        depth_dy = depth_dyp - depth;
    }

    float wx = (wsize.x - 2.0f * wpos.x) / (wsize.x * proj_matrix[0][0]);
    float wy = (wsize.y - 2.0f * wpos.y) / (wsize.y * proj_matrix[1][1]);

    // Eyespace position derivatives
    float3 pdx = normalize(float3(C.x * depth + wx * depth_dx, wy * depth_dx, depth_dx));
    float3 pdy = normalize(float3(wx * depth_dy, C.y * depth + wy * depth_dy, depth_dy));

    return normalize(cross(pdx, pdy));
}

void main(
    int2 wpos : WPOS,
    uniform sampler2D colorin,
    uniform sampler2D depth_values,
    uniform float4x4 modelview_matrix,
    uniform float4x4 proj_matrix,
    uniform float2 window_size,
    uniform float2 C,

    out float4 colorout : COLOR
    )
{
    // Extract the parameters we passed in the render targets
    float4 color  = tex2Dfetch(colorin, int4(wpos,0,0));
    float depth  = tex2Dfetch(depth_values, int4(wpos,0,0)).x;
    float3 normalizedColor = color.rgb / color.a;
    float shininess = 50.0;

    if (depth >= 1)
        discard;

    const float3 lightdir = float3(0, 1, 2);
    const float3 eye_loc = float3(0,0,1);
    const float4 b = float4(1.0);
    float3 normal = calc_normal(wpos, depth, depth_values, C, window_size, proj_matrix);
    normal = mul(normal, inverse(float3x3(modelview_matrix)));
    normal.xz = -normal.xz;

    // Calculate position in eye space
    float3 p_eye = mul(modelview_matrix, float4(wpos, depth, 0.0)).xyz;

    // eye location position in eye space
    float3 eye_eye = mul(modelview_matrix, float4(eye_loc, 0.0)).xyz;

    // view vector
    float3 viewdir = normalize(eye_eye - p_eye);

    // Phong lighting model 
    float NV = dot(normal, viewdir);

    float3 halfvec = normalize(lightdir + viewdir);
    float NH = dot(normal, halfvec);


    float diffuse = max(dot(normal, lightdir), 0.0);

    // Phong specular component
    float specular = pow(max(NH, 0.0), shininess);
    
    // Refraction indices for air and water
    float air_refraction = 1.0;
    float water_refraction = 1.3333;

    // Schlick's approximation. Approximates the fresnel equation for refraction and reflection
    float r0 = pow((air_refraction - water_refraction) / (air_refraction + water_refraction), 2);
    float schlick = (r0 + ((1-r0)*pow((1 - (abs(NV))), 5)));

    // Final color
    // colorout = float4(diffuse * normalizedColor + schlick + specular, 1.0);
    // colorout = float4(normal, 1.0);
    colorout = float4(depth, depth, depth ,1);
}



