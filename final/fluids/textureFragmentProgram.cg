float2 toCoord(float2 point, float2 window_size)
{
    return float2(point.x/(window_size.x-1.0), point.y/(window_size.y-1.0));
}

float3 calc_normal(float2 uv_coord, float2 wpos, float depth, uniform sampler2D depth_values, uniform float2 C, uniform float2 wsize, uniform float4x4 proj_matrix) {
    //Calculate normal as according to the paper
    float2 dx = toCoord(float2(1,0), wsize);
    float2 dy = toCoord(float2(0,1), wsize);

    float depth_dxp = tex2D(depth_values, uv_coord + dx).x;
    float depth_dxn = tex2D(depth_values, uv_coord - dx).x;
    float depth_dx = (depth_dxp - depth_dxn) / 2.0;

    float depth_dyp = tex2D(depth_values, uv_coord + dy).x;
    float depth_dyn = tex2D(depth_values, uv_coord - dy).x;
    float depth_dy = (depth_dyp - depth_dyn) / 2.0;

    float2 depth_d = float2((depth_dxp == 0.0 || depth_dxn == 0.0) ? 0.0 : depth_dx, (depth_dyp == 0.0 || depth_dyn == 0.0) ? 0.0 : depth_dy);

    float3 N = float3(-C.y * depth_d.x, -C.x * depth_d.y, C.x * C.y * depth) * depth;
    return normalize(N);
}

float4 main(
    int2 wpos : WPOS,
    float2 coord : TEXCOORD0,
    uniform sampler2D colorin,
    uniform sampler2D depth_values,
    uniform float4x4 modelview_matrix,
    uniform float4x4 modelview_IT_matrix,
    uniform float4x4 proj_matrix,
    uniform float3 eye_loc,
    uniform float3 light_dir,
    uniform float2 window_size,
    uniform float method
    ) : COLOR
{
    // Extract the parameters we passed in the render targets
    float4 color  = tex2D(colorin, coord);
    float depth  = tex2D(depth_values, coord).x;
    float3 normalizedColor = color.rgb / color.a;
    float shininess = 50.0;

    if (depth >= 1)
        discard;

    float2 C = float2(2.0 / (window_size.x * -proj_matrix[0][0]), 2.0 / (window_size.y * -proj_matrix[1][1]));

    float3 normal = mul(modelview_IT_matrix, float4(calc_normal(coord, wpos, depth, depth_values, C, window_size, proj_matrix), 0.0)).xyz;
    // Calculate position in eye space
    float3 p_eye = mul(modelview_matrix, float4(wpos, depth, 0.0)).xyz;

    // eye location position in eye space
    float3 eye_eye = mul(modelview_matrix, float4(eye_loc, 0.0)).xyz;

    // view vector
    float3 view_dir = normalize(eye_eye - p_eye);

    // Phong lighting model 
    float NV = dot(normal, view_dir);

    float3 halfvec = normalize(light_dir + view_dir);
    float NH = dot(normal, halfvec);

    //Prevent ugly black borders around
    float diffuse = max(dot(normal, light_dir), 0.5);

    // Phong specular component
    float specular = pow(max(NH, 0.0), shininess);
    
    // Refraction indices for air and water
    float air_refraction = 1.0;
    float water_refraction = 1.3333;
    float T = color.r;
    float4 c_beer = float4(exp(-.6*T), exp(-.2*T), exp(-.05*T), 1-exp(-3*T));

    // Schlick's approximation. Approximates the fresnel equation for refraction and reflection
    float r0 = pow((air_refraction - water_refraction) / (air_refraction + water_refraction), 2.0);
    float schlick = (r0 + ((1.0-r0)*pow((1.0 - (abs(NV))), 5.0)));

    // Final color
    if (method == 1)
        return float4(diffuse * normalizedColor + schlick + specular, 1.0);
    if (method == 2)
        return float4(depth, depth, depth, 1);
    if (method == 3)
        return float4(normal, 1.0);
}