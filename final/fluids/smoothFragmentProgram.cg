float2 derivative(uniform sampler2D depth_values, float2 wpos)
{
	float x_derivate = tex2Dfetch(depth_values, int4(wpos.x + 1, wpos.y,0,0))  - tex2Dfetch(depth_values, int4(wpos.x - 1, wpos.y,0,0));
	float y_derivate = tex2Dfetch(depth_values, int4(wpos.x, wpos.y + 1,0,0))  - tex2Dfetch(depth_values, int4(wpos.x, wpos.y - 1,0,0));
	return float2 (x_derivate, y_derivate);
}

void main(
	float2 wpos : WPOS,

	uniform float2 C,
	uniform sampler2D depth_values,

	out float depth_out : DEPTH,
	out float4 col : COLOR
	)
{
	float depth = tex2Dfetch(depth_values, int4(wpos,0,0));
	col = float4(depth, depth, depth, 1);
	if (depth >= 1)
	{
		discard;
	}
	// Derive the depth values in both the x, and y direction
	float2 derivatives = derivative(depth_values, wpos);
	//Determine normal as in the paper using finite differencing
	float3 normal = float3(-C.y * derivatives.x, -C.x * derivatives.y, C.x * C.y * depth); 
	// Save the squared components as this may be useful for determining curvature
	float D = dot(normal, normal);
	// Normalize!
	float3 norm_normal = normalize(normal);
	col = float4(norm_normal, 1);
}