float2 wposToUVcoord(float2 wpos, float2 window_size)
{
	return float2(wpos.x/(window_size.x-1.0), wpos.y/(window_size.y-1.0));
}

float3 mean_curvature(float2 uv_coord, float depth, uniform sampler2D depth_values, uniform float2 C, uniform float2 window_size)
{
	// delta_x and delta_y are small offsets to determine curvature
	float2 dx = wposToUVcoord(float2(1,0), window_size);
	float2 dy = wposToUVcoord(float2(0,1), window_size);
	// First order central differences
	float depth_dxp = tex2D(depth_values, uv_coord + dx).x;
	float depth_dxn = tex2D(depth_values, uv_coord - dx).x;
	float depth_dyp = tex2D(depth_values, uv_coord + dy).x;
	float depth_dyn = tex2D(depth_values, uv_coord - dy).x;
	float depth_dx = (depth_dxp - depth_dxn) / 2.0;
	float depth_dy = (depth_dyp - depth_dyn) / 2.0;
	if (depth_dxp == 0 || depth_dxn == 0)
	{
		depth_dx = 0;
	}
	if (depth_dyp == 0 || depth_dyn == 0)
	{
		depth_dy = 0;
	}

	// Second order central differences
	float depth_dx2 = depth_dxp + depth_dxn - (2 * depth);
	float depth_dy2 = depth_dyp + depth_dyn - (2 * depth);
	float depth_dxpyp = tex2D(depth_values, uv_coord + dx + dy);
	float depth_dxnyn = tex2D(depth_values, uv_coord - dx - dy);
	float depth_dxpyn = tex2D(depth_values, uv_coord + dx - dy);
	float depth_dxnyp = tex2D(depth_values, uv_coord - dx + dy);
	float depth_dxy	= (depth_dxpyp + depth_dxnyn - depth_dxpyn - depth_dxnyp) / 4.0;
	// TODO: Misschien verkeerde C

	// D from paper
	float D = C.y * C.y * depth_dx * depth_dx + C.x * C.x * depth_dy * depth_dy + C.x * C.x * C.y * C.y * depth * depth;
	float D_dx = C.y * C.y * 2.0 * depth_dx * depth_dx2 + C.x * C.x * 2.0 * depth_dy * depth_dxy + C.x * C.x * C.y * C.y * 2.0 * depth * depth_dx;
	float D_dy = C.y * C.y * 2.0 * depth_dx * depth_dxy + C.x * C.x * 2.0 * depth_dy * depth_dy2 + C.x * C.x * C.y * C.y * 2.0 * depth * depth_dy;
	float Ex = 0.5 * depth_dx * D_dx - depth_dx2 * D;
	float Ey = 0.5 * depth_dy * D_dy - depth_dy2 * D;
	// Finally, mean curvature
	float h = 0.5 * ((C.y * Ex + C.x * Ey) / pow(D, 1.5f));
	return(float3(depth_dx, depth_dy, h));
}

float main(
	// https://github.com/halcy/simpleflow/blob/master/WaterSim2/curvatureflow.frag
	float2 wpos : WPOS,

	uniform float2 C,
	uniform float2 window_size,
	uniform sampler2D depth_values
	)
	: DEPTH
{
	float4 depth_fetch = tex2Dfetch(depth_values, int4(wpos,0,0));
	float depth = depth_fetch.x;
	float2 uv_coord = wposToUVcoord(wpos, window_size);
	if (depth >= 1)
	{
		discard;
	}
	if (depth == 0)
		return 0;

	float dt = 0.00055f;
	float dzt = 1000.0f;

	float3 curvature = mean_curvature(uv_coord, depth, depth_values, C, window_size);

	return depth + curvature.z * dt * (1.0 + (abs(curvature.x) + abs(curvature.y)) * dzt);
}