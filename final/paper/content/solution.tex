%!TEX root = ../report.tex
\section{Solution}
The paper introduced by van der Laan et al. \cite{van2009screen} provides a fitting solution to our problem.
The paper describes a method for visualizing fluids simulated using SPH in a natural way.
The goal of the paper is to provide a solution to our aforementioned problem.
According to the paper, they want to create:
\begin{enumerate}
	\item \label{en:item1} Achieves real-time performance, with a configurable speed versus quality trade-off.
	\item \label{en:item2} Does all the processing, rendering and shading steps directly on the graphics hardware.
	\item \label{en:item3} Smooths the surface to prevent the fluid from looking blobby or jelly-like.
	\item \label{en:item4} Is not based on polygonization, and thus does not suffer from the associated tessellation artifacts.
\end{enumerate}

Items \ref{en:item1} and \ref{en:item3} have a direct connection with our goals and items \ref{en:item2} and \ref{en:item4} are ways to enable these goals.

The method described in the paper consists of multiple passes. It assumes that there is a functional SPH simulation where each fluid particle has a density. Then each frame the following steps are performed:
\begin{enumerate}
	\item Splat points as spheres and determine depth values per fragment
	\item Smooth the spheres based on curvature flow
	\item Attenuate colors based on thickness
	\item Add noise texture and advect throughout the simulation
	\item Add foam
	\item Render using Fresnel and Phong equations
\end{enumerate}

\subsection{Depth determination}
It is desirable to determine depth of fragment in the simulation in order to know which fragments are part of the surface. 
In order to obtain these depth values, the points from the SPH simulation are splatted to discs and their fragments are subjected to a hardware depth test. 
This result is subsequently written to a depth buffer. 
Note that merely the depth value is splatted and the color and normal attributes are left unchanged as they will be changed in later steps.

\subsection{Smoothing}
Smoothing is a critical component in the paper. It is responsible for creating a smooth surface from a set of points so to avoid a blobby and jelly-like surface which is undesirable. The paper argues that this is a better approach than using Gaussian blurring because it performs better and ought to produce better results because there will be no silhouette blurring. 
This is achieved by translating points along the $z$-axis according the curvature flow. 

Curvature flow is defined by the divergence of the normal by \(2H = \nabla \cdot \hat{\mathbf{n}}\). Subsequently, depth values can be displaced every timestep based on the curvature in that point, as \(\frac{\partial z}{\partial t} = H\).

To obtain normals, the point of which the normal needs to be determined is mapped back to a point in view by inverting the projection transformation. This point is called % $\mathbf{P} = \Colvec[;]{a;b;c} $
$\Colvec{a}\Colvec{a,b}\Colvec[;]{a;b;c}$


\subsection{Thickness}

\subsection{Noise}

\subsection{Foam}

\subsection{Rendering}

\subsection{Fit}